#! /usr/local/bin/perl
eval "exec /usr/local/bin/perl -S $0 $*"
	if $braindead;

$0 =~ s%.*/%%;					# deslash prog name

$BELL='';
$n = $d = 0;					# do not rm or rmdir
$b = $q = 0;					# nobeep & noquiet
$e = 0;						# always equal
$a = 0;						# dont rm @
$U = $G = $M = 0;				# same owner, group, mode

sub usage
{
    die("@_

usage: $0 [-q] [-b] [-d] [-n] [-e] [-U] [-G] [-M] src dst
	-q	quiet
	-b	beep if different
	-n	no file removed
	-d	no dirs removed
	-e	files always equal
	-a	kill @ files too
	-U	require same uid
	-G	require same gid
	-M	require same mode

Recursive Compare and Remove SRC relative to DST
SRC and DST may be relative or absolute pathnames

Flags:  = equal files,		# different files
	~ equal devices,	* different devices
	@ equal symlink
	< backward symlink,	> forward symlink
	? no peer,		% different types
	\\ down directory,	/ up directory
");
}

sub pwd
{
    local($pwd) = `pwd`;			# what if it fails?
    chop($pwd);
    return($pwd);
}

sub cd
{
    chdir($_[0]) && return 1;			# success
    die "cd $_[0]: $!\n" if $_[1];		# hard failure
    return 0;					# soft failure
}

option:
{
    last option unless @ARGV;			# no args left
    last option unless $ARGV[0] =~ m/^-.$/;	# not an option
    $_ = shift;					# it is
    
    /-q/ && ++$q && next option;		# quiet
    /-b/ && ++$b && next option;		# beep if diff
    /-d/ && ++$d && next option;		# no rmdir
    /-n/ && ++$n && next option;		# no rm
    /-e/ && ++$e && next option;		# always equal
    /-a/ && ++$a && next option;		# rm @ files too
    /-U/ && ++$U && next option;		# same uid
    /-O/ && ++$U && next option;		# alias
    /-G/ && ++$G && next option;		# same gid
    /-M/ && ++$M && next option;		# same mode
    
    &usage("unknown option: $_");		# complain
   
} continue {
    redo option;
}

$BELL="\007" if $b;				# squawk
$d |= $n;					# keep dirs too

$src = shift || &usage("Missing SRC");
$dst = shift || &usage("Missing DST");
$lvl = shift && &usage("Too Many Files");

$src =~ m'^/' || ($cwd = &pwd);			# remember cwd

&cd($dst,1); $dst = &pwd;			# make dst absolute
&cd($cwd,1) if $cwd;				# original cwd
&cd($src,1); $src = &pwd;			# make src absolute

$src eq $dst &&					# sanity clause
    die("$0: You almost removed the entire tree!\n");

&RR($src, $dst, '');				# start recursing

exit(0);

sub same
{
    return 1 if $e;				# always same
    return 0 if ($U && ($SS[4] != $DS[4]));	# uid check
    return 0 if ($G && ($SS[5] != $DS[5]));	# gid check
    return 0 if ($M && ($SS[2] != $DS[2]));	# mode check
    return 0 if ($SS[7] != $DS[7]);		# size check
    return 1 if ($SS[0] == $DS[0] &&		# files are
		 $SS[1] == $DS[1]);		# identical
    
    close(sf); close(df);			# clean previous
    open(sf) || return 0;			# open src
    open(df) || return 0;			# open dst
    
    while ($size = sysread(sf,$SS,1<<16)) {	# 64K
	$size == sysread(df,$DS,$size) ||
	    return 0;
	$SS eq $DS || return 0;			# compare
    }
    return 1;
}

sub RR
{
    local($src,$dst,$lvl) = @_;
    local($sf,$df);
    local($FILE,@FILE);
    local($empty) = !$d;			# ok to rmdir
    local($at) = 0;
    
    &cd($src,0) || return;			# bailing out near line 1
    
    opendir(DIR,'.') || die("$0: opendir: $!\n");
    @FILE = sort(readdir(DIR));			# ls .
    closedir(DIR);
    
  file:
    for $FILE (@FILE) {				# file loop
	
	next file if $FILE =~ m/^\.\.?$/;	# skip . & ..
	
	$df = "$dst/$FILE";			# dst file name
	$sf = "$src/$FILE";			# src file name
	
	$DS = -l $df;				# lstat dst
	
	defined $DS || do {			# no dst file
	    $q || print "$lvl $BELL? $sf\n";	# none
	    next file;
	};
	
	@DS = $DS ? stat($df) : stat(_);	# save dst stat
	$SS = -l $sf;				# lstat src
	@SS = $SS ? stat($sf) : stat(_);	# save src stat
	
if (0) {
	(-S _ || -c _ || -b _ || -p _) && do {	# strange src type
	    $q || print "$lvl $BELL& $sf\n";
	    next file;
	};
}

	$SS && $DS && do {			# both symlinks
	    if (readlink($sf) eq readlink($df)) {
		$q || print "$lvl @ $sf\n";	# matching
		$n || unlink($sf);		# remove it
	    } else {
		$q || print "$lvl > $sf\n";	# fwd symlink
	    }
	    next file;
	};

	$SS[2] &= ((1 << 16) - 1);		# keep mode
	$DS[2] &= ((1 << 16) - 1);		# bits short

	($SS[2] ^ $DS[2]) >> 12 && do {		# different types
	    $q || print "$lvl $BELL% $sf\n";
	    next file;
	};

	$SS < $DS && do {			# dst symlink but not src
	    $q || print "$lvl < $sf\n";		# bwd symlink
	    next file;
	};

	(-S _ || -c _ || -b _ || -p _) && do {	# devices
	    if ($SS[6] == $DS[6]) {		# major/minor
		$q || print "$lvl ~ $sf\n";
		$n || unlink($sf);		# remove it
	    } else {
		$q || print "$lvl $BELL* $sf\n";
	    }
	    next file;
	};

	$SS < -d _ && do {			# both directorys
	    $q || print "$lvl \\ $sf\n";	# enter dir
	    &RR($sf,$df,'.' . $lvl) &&		# recurse
	        rmdir($sf);			# zap dir
	    $q || print "$lvl / $sf\n";		# exit dir
	    next file;
	};

	if (&same) {				# equal
	    $q || print "$lvl = $sf\n";		# say so
	    if ($FILE eq '@') {
		$at = $a;			# kill @ later
	    } else {
		$n || unlink($sf);		# remove it
	    }
	} else {
	    $q || print "$lvl $BELL# $sf\n"; 	# complain
	    $empty = 0;				# now cant rmdir
	}
	next file;
    }
    $at && unlink('@');				# see above
    &cd("..",0);				# back to parent dir
    return $empty;				# can rmdir
}

# Local Variables:
# mode: perl
# comment-column: 48
# End:
