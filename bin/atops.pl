#! /usr/local/bin/perl
eval "exec perl -S $0 $*"
        if $braindead;
################################################################
#	ASCII FILTER FOR POSTSCRIPT PRINTERS
################################################################
#
# This program converts plain ASCII text into PostScript,
# passing existing PostScript files thru untouched.
#
# It is designed to be used as the "if=" entry in /etc/printcap,
# and is called with the following standard input filter options:
#
#	prog [-c] -wWidth -lLength -iIndent -n login -h host acctfile
#
# Standard input is the file to be printed and standard output
# is the printer itself. Standard error is a log file to complain to.
# The last argument is the name of the accounting file, if present.
#
# The following libertys are taken with the option discipline and the user:
#
# + Non standard tabs are specified with the -i (indent) option.
#
# + The text is centered within the page. There is no way to actually indent.
#
# + Point size is fixed at 11 point, good for 66 lines of 80 columns.
#
# + The -c option, generated by "lpr -l", means "landscape mode".
#   Landscape is two columns of 66 lines, 80 columns in 8.5 point font.
#
# + This program started out a just a regular filter, so if the
#   accounting file is literally "-" or "--", the rest of the arguments
#   are taken as one big file. This happens naturally in perl.
#
################################################################

################################################################
#	INTERESTING FEATURES
################################################################
#
# [1] The program optimizes leading white space into motion.
#     Trailing whitespace is deleted. Intraline space is printed.
#
# [2] A document with no marks produces no output, not even a prolog.
#
# [3] The coordinate system is transformed and scaled so that row
#     and column coordinates can be used directly.
#
# [4] Because of the above, the font need not be scaled. Acually,
#     I lied: it is scaled in the X direction by the aspect ratio.
#
# [5] The origin is at the top left margin. The Y axis is inverted,
#     using zero origin positioning. The X axis is normal.
#
# [6] No blank pages are ever printed, even if generated by
#     a series of newlines or formfeeds. Save the trees!
#     I sure killed enough of them debugging this program.
#
# [7] If the current (spool) directory contains an executable
#     file named "IF", it is inserted into end of the pipeline
#     and invoked with the options we were called with.
#     This allows wrapping an existing filter.
#
# [8] Underlining and overstriking via backspaces are supported.
#
# [9] The clipping path is printed on each page. Real cute!
#
# [10] Lines are silently truncated at 80 columns. Tough!
#
# [11] LATE FLASH! Because lpr -l -p does not run the text thru pr,
#      I have further overloaded the -i parameter. The last two
#      decimal digits are the tab expansion as usual. The hundreds
#      digit (and thousands if I add more feechurs) is treated as
#      a flags word: 1 autowraps, 2 & 4 add Bold and Oblique
#      to the Courier font (why I did this, I do not know!), and
#      8 forces landscape mode. Try lpr -p -i808 to get the
#      effect that lpr -p -l will not produce. lpr -i108 autowraps.
#
# [12] The NeXT print spooling system is really horrendous. I could
#      not make it work as a filter, so I effectively modified the
#      file in place, and chained to it. 
#
# [13] I still have a problem with border prints on some pages on NeXTs.
#      I don't know why. Adding the DSC comments didn't seem to help.
#      I never see it on other printers, so I blame it on NeXT. On the
#      other hand, maybe that flummery I pulled by leaving the border
#      in the graphics state did it. Can any PostScript expert comment?
#
################################################################

################################################################
#	CONSTANTS: Default Values
################################################################

$BOD = 0;					# Begin Document
$BOP = 1;					# Begin Page
$BOL = 2;					# Begin Line
$BOC = 3;					# Begin Char

$LS = 0;					# portrait
$TAB = 8;					# -i indent
$ROWS = 66;					# -l lines per page
$COLS = 80;					# -w cols per line
$FONT = 'Courier';				# fixed pitch font
$PRTR = 'laser';				# any printer
$AUTOWRAP = 1;					# not yet

################################################################
#	VARIABLES
################################################################

$USER = '';					# use these...
$HOST = '';					# ...for easy...
$PAGE = 0;					# ...accounting

$FILT = '';					# filter name
$NeXT = '';					# NeXT file
$CHLD = 0;					# child pid

$row = 0;					# current line
$col = 0;					# current column
$half = 0;					# current half
$state = $BOD;					# start state

################################################################
#	BUG: Debug Print Variables 
################################################################

sub BUG
{
    print("NEWPAGE
 /BUG 30 def
 [ /LS /PT /RT /ROWS /COLS /CH /CW /PL /PW /DX /DY /LM /TM /X2 /Y2 ]
 { 40 BUG moveto
 dup  10 string cvs show ( = ) show
 load 10 string cvs show
 /BUG dup load 1 add store } forall
 ENDPAGE ");
}

################################################################

################################################################
#	HEADER: create DSC Comments
################################################################

sub header
{
    $ORIENT = $LS ? 'Landscape' : 'Portrait';

    $HEADER = "%!PS-Adobe-3.0
%%Creator: atops
%%CreationDate: $hour:$min:$sec $mon/$mday/$year
%%For: $USER@$HOST printing to $PRTR
%%DocumentData: Clean7Bit
%%DocumentNeededResources: font $FONT
%%DocumentMedia: Plain 612 792 75 white ()
%%LanguageLevel: 1
%%Orientation: $ORIENT
%%PageOrder: Ascend
%%Pages: (atend)
%%EndComments
";
}

################################################################

################################################################
#	Generate Document Setup
################################################################

sub prolog
{
    $RT = $LS ? 0.52 : 0.6;			# for Courier, at least
    $PT = $LS ? 8.5 : 11;			# fixed point size
    $CH = $PT;					# char height
    $CW = $PT * $RT;				# char width
    $PL = 72 * $PT;				# page length
    $PW = 11 * 8.5 * 72 * 72 / $PL;		# page width

    $PROLOG = "
%%BeginProlog
/E { } def
/NEWPAGE { /MINOR save def stroke } bind def
/NEWHALF { X2 0 translate } bind def
/ENDPAGE { showpage MINOR restore } bind def
/LINE { 4 1 roll pop exch moveto -2 exch 0 exch 8 exch widthshow } bind def
%%EndProlog
%%BeginSetup
%%IncludeResource: font $FONT

/MAJOR save def

/LS $LS 0 ne def /PT $PT def /RT $RT def
/ROWS $ROWS def /COLS $COLS def
/CH $CH def /CW $CW def
/PL $PL def /PW $PW def

gsave
LS { 90 rotate } { 0 PL translate } ifelse CW CH neg scale

/$FONT findfont [ 1 0.6 div 0 0 -1 0 0 ] makefont setfont

clippath flattenpath pathbbox

3 index 3 index translate
3 -1 roll sub /DY exch def exch sub /DX exch def
/X2 DX 2 div def /Y2 DY 2 div def

LS { X2 0 moveto X2 DY lineto } if

DX LS { 2 div } if COLS sub 2 div /LM exch def
DY                 ROWS sub 2 div /TM exch def
LM TM 1 add translate

%%EndSetup
";
}

################################################################

################################################################
#	PROCESS OPTIONS
################################################################

sub options
{
    while ($_ = shift(@ARGV)) {

	push(@@, $_);				# save args
	++$LS, next if /^-c$/;			# LOCAL -- landscape
	$BUG = 1, next if /^-BUG$/;		# LOCAL -- DEBUG

	$ROWS = $1, next if /^-l(\d+)$/;	# lines per page
	$COLS = $1, next if /^-w(\d+)$/;	# columns per line
	$TAB = $1, next if /^-i(\d+)$/;		# indent (tab expand)

	push(@@, $USER = shift(@ARGV)), next if /^-n$/;	# use these...
	push(@@, $HOST = shift(@ARGV)), next if /^-h$/;	# ...for accounting

	# The next two options are for the NeXT
	# I cannot make their filter work as a filter
	# so I just mung the file and let them do their thing

	push(@@, $PRTR = shift(@ARGV)), next if /^-p$/;	# NeXT -- printer
	/^-f$/ && do {				# NeXT -- file
	    push(@@, $NeXT = shift(@ARGV));	# save it.
	    open(STDOUT, ">$NeXT.$$") ||	# create converted file
		die("open(>$NeXT.$$): $!\n");
	    next;
	};

	last if /^--?$/;			# LOCAL -- allow files

	$ACCT = $_;				# last arg is acct
	close(ACCT);				# in case multiple given
	open(ACCT, ">>$ACCT") ||		# open account file
	    warn("open(>>$ACCT: $!\n");		# or complain
    }

    $FLAGS = int($TAB/100); $TAB %= 100;	# get flags
    $AUTOWRAP = $FLAGS & 1;			# autowrap
    $FONT .= '-' if $FLAGS & 6;			# have...
    $FONT .= 'Bold' if $FLAGS & 2;		# ...some...
    $FONT .= 'Oblique' if $FLAGS & 4;		# ...fun
    $LS |= ($FLAGS & 8) > 0;			# -l & -p do not mix

    $TAB =  8 unless $TAB;			# protect...
    $ROWS = 66 unless $ROWS;			# ...against...
    $COLS = 80 unless $COLS;			# ...bogosity
}

################################################################

################################################################
#	RUN: exec a program, possibly closing descriptors
################################################################

sub run
{
    $_[0] & 1 && close(STDIN);			# bit mask
    $_[0] & 2 && close(STDOUT);			# of files
    shift & 4 && close(STDERR);			# to close
    exec(@_) || die("exec(@_): $!\n");		# run or die
}

################################################################
#	CONNECT ANY EXISTING INPUT FILTERS TO PIPELINE 
################################################################

sub pipeline
{
    $FILT = readlink('.IF=');
    return unless $FILT;			# no filter
    return if $NeXT;				# defer NeXT filter

    pipe(RD, WR) || die("pipe(RD, WR): $!\n");	# plumbing

    if ($CHLD = fork) {				# parent...
	open(STDOUT, '>&WR') ||			# ...writes pipe
	    die("open(STDOUT, >&WR): $!\n");
    } else {					# child...
	open(STDIN,  '<&RD') ||			# ...reads pipe
	    die("open(STDIN,  <&RD): $!\n");
    }

    close(RD); close(WR);			# neither needs these
    $CHLD && return;				# parent returns
    &run(0, $FILT, @@);				# child becomes filter
}

################################################################
#	INTERRUPT HANDLER -- say that job should be reprinted
################################################################

sub interrupt
{
    &acct("$USER@$HOST: Terminated. Job will be reprinted");
    exit(1);
}

################################################################

################################################################
#	BEGIN/END DOCUMENT/PAGE/LINE
################################################################

sub BegDoc
{
    print($HEADER, $PROLOG);
    $state = $BOP;
}

sub BegPage
{
    ++$PAGE;
    print("%%Page: $PAGE $PAGE\n");
    print("%%BeginPageSetup\nNEWPAGE\n%%EndPageSetup\n");
    $state = $BOL;
}

sub BegLine
{
    printf("%2d %2d %1d (", $row, $col, $half);
    $state = $BOC;
}

sub EndLine
{
    $col = 0;
    return if $state < $BOC;
    print(") LINE\n");
    $state = $BOL;
}

sub EndPage
{
    &EndLine;
    $row = 0;
    return if $state < $BOL;
    print("NEWHALF\n"), return if $LS && ($half ^= 1);
    print("%%PageTrailer\nENDPAGE\n");
    $state = $BOP;
}

sub EndDoc
{
    $half = 1;					# force closure
    &EndPage;
    return if $state < $BOP;
    print("%%Trailer\n");			# begin Trailer
    print("%%Pages: $PAGE\n");			# how many pages
    print("grestore MAJOR restore\n");		# fix graphics
    print("%%EOF\n");				# the final word
}

################################################################

################################################################
#	DOCHAR: Process each character
################################################################

sub dochar
{
    /\t/ && do {
	$_ = " ";
	do { &dochar; } while($col % $TAB);	# loop over spaces
	return;
    };

    /[\b]/ && $state < $BOC && do {
	--$col if $col;				# ignore at BOL
	return;
    };

    / / && $state < $BOC && do {
	return if ++$col < $COLS;
	return unless $AUTOWRAP;
	$_ = "\n";				# too many chars
    };

    /\r/ && ($_ = "\n") && --$row;		# fake as newline

    /\n/ && do {
	&EndLine;
	return if ++$row < $ROWS;
	$_ = "\f";				# too many lines
    };

    /\f/ && do {
	&EndPage;
	return;
    };

    &BegDoc  if $state == $BOD;
    &BegPage if $state == $BOP;
    &BegLine if $state == $BOL;

    /[()\\]/ && ($_ = "\\$_");			# needs quoting
    /[\b]/ && ($_ = "\\b");			# needs quoting
    print;

    /[\b]/ ? --$col : ++$col;			# bump column
    return if $col < $COLS;
    return unless $AUTOWRAP;
    $_ = "\n";
    &dochar;
}

################################################################

################################################################
#	MAIN PROGRAM
################################################################

sub main
{
    $0 =~ s%.*/%%;				# basename prog
    select(STDERR); $| = 1;			# piping hot!
    select(STDOUT); $| = 1;			# piping hot!
    &options;					# process options
    &acct($0, @@);				# signon
    &pipeline;					# connect filters
    &header;					# create header
    &prolog;					# create prolog

    $_ = <>;					# get first line
    if (/^%!/) {				# already postscript
	&acct("$USER@$HOST: PostScript.");	# say so
	print; print while(<>);			# just copy it
	exit(0) unless $NeXT;			# done, usually
    } else {					# needs conversion

	do {					# use first line
	    s/[ \t]+$//;			# nuke trailing WS
	    $CHAR += length; $LINE++;		# bump counts
#	tr/aeiouAEIOU/AEIOUaeiou/;		# DEBUG
	    grep(&dochar, split(//));		# char loop
	} while (<>);				# line loop
	
	&EndDoc;				# cleanup

	&acct("$USER@$HOST $CHAR chars, $LINE lines, $PAGE pages");
    }

    if ($NeXT) {				# NeXT kluge
	unlink($NeXT) ||			# replace orig file
	    die("unlink($NeXT): $!\n");
	rename("$NeXT.$$", $NeXT) ||		# with conversion
	    die("rename($NeXT.$$, $NeXT): $!\n");
	&run(7, $FILT, @@);			# become filter
    }

    $? = 0;					# OK so far
    $CHLD && wait;				# wait for any children
    $?;						# return status
}

################################################################

################################################################
#	ACCOUNTING: sign on and off
################################################################

sub acct
{
    $ACCT || return;
    $OUT = $NeXT ? 'STDERR' : 'ACCT';

    $hostname || chop($hostname = `hostname`);
    $HOST = $hostname unless $HOST;		# must be us
    $USER = $getlogin unless $USER;		# must be us

    ($sec, $min, $hour, $mday, $mon, $year,	# what time
     $wday, $yday, $isdst) = localtime(time);	# is it?

    printf($OUT "%02d/%02d %2d:%02d:%02d %s[%05d]: @_\n",
	   ++$mon, $mday, $hour, $min, $sec, $hostname, $$);
#	   (Sun, Mon, Tue, Wed, Thu, Fri, Sat)[$wday],
#	   (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Dec)[$mon],
}

################################################################
#	RUN THE BLOODY PROGRAM
################################################################

exit(&main);

################################################################

# Local Variables:
# mode: perl
# comment-column: 48
# End:
